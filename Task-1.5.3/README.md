### Задание

Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна - количество вызовов функции растет экспоненциально с ростом значения аргумента. GHCi позволяет отслеживать использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду :set +s:

`GHCi> :set +s`

`GHCi> fibonacci 30`

`832040`

`(8.36 secs, 298293400 bytes)`

С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

### Ответ

`f :: Integer -> Integer -> Integer -> Integer`

`f a b 0 = a`

`f a b n | n > 0 = f b (a + b) (n - 1)`

`        | n < 0 = f (b - a) a (n + 1)`

`fibonacci = f 0 1`

